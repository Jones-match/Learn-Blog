count(*) = count(1) > count(主键) > count(普通字段)

# COUNT

count 是统计在符合查询条件中， **函数指定的参数**不为NULL 的记录个数



count执行过程：

在count 函数统计有多少个记录时，MySQL 会在Server层维护一个count 变量

Server层会循环从InnoDB 中读取一条记录，如果count指定的参数不为NULL，count变量就会加1，直到符合查询的条件全部读完，退出循环

然后将count变量的值发送给客户端



## COUNT(1)

count（1）中，1 就是单纯的数字，永远不可能为NULL，因为执行过程等价于统计表中有多少个记录



当表中只有主键索引而没有二级索引时，在遍历记录的时候，不会读取记录中的任何字段的值（因为参数为1，不是字段，因此不需要读取记录中的字段值，所以Server层每从InnoDB中读取一个记录，都会将count 变量加1）

与count（主键）相比，少了读取字段中的值的环节，因此效率会高于主键

而当表中有二级索引时，遍历的对象会自动更改为二级索引 



## COUNT(主键)

当表里有二级索引时，count（主键）会去遍历二级索引，而不会去遍历聚集索引

===因为相同数量的二级索引可以比聚集索引占用更少的存储空间，因此二级索引树会比聚集索引树要小 -- 遍历二级索引的I/O 成本会更小





## COUNT(*)

等价于count(0)，性能与count(1)相同



优化：

当有多个二级索引时，count(1) 和 count(*) 在执行的时候，会自动挑选key_len 最小的二级索引 

只有在没有二级索引的时候，才会使用主键



## COUNT(字段)

全盘扫描来计数

除非是用来统计某列不为NULL 的记录条数，否则尽量不用这种方法来进行统计







# 通过遍历计数

MyISAM引擎：每个数据表中都有一个meta 信息存储了row_count 值，直接读取row_count 值就是count 函数的执行结果（由表级锁保证一致性）

InnoDB 支持事务，同一个时刻的多个查询，由于多版本并发控制的原因，无法像MyISAM一样，只维护一个row_count 变量



当加上where 条件语句后，MyISAM 和InnoDB就没有区别了，都需要扫描整个表来统计记录个数



# 优化COUNT(*)

## 近似

当业务对于精度要求不是很高的时候，可以使用近似值来统计

show table status 或 explain 命令获取记录的估计值



## 额外表保存计数值

可以将计数值保存到单独的一张计数表中，每当在数据表中插入一条记录时，就将计数表中的计数字段 + 1

在新增和删除操作时，需要额外维护这个计数表









