读锁，共享锁，S 锁， 多个事务对于同一数据可以共享一把锁，都能读不能修改



写锁，排他锁，独占锁，X 锁，获得排他锁的事务可以对数据进行读取和修改，其他事务不能再加其他锁





当锁处于WAITING 状态时，表示锁并没有成功加上



# 全局锁

使用全局锁

```mysql
flush tables with read lock
```

执行后 ，**整个<font color="red">数据库</font>处于只读状态**

其他线程在进行修改操作时就会阻塞

insert, delete, update, alter table, drop table

释放：

```MySQL 
unlock tables
```



当会话断开时，全局锁自动释放



应用场景：

全库逻辑备份

在备份数据库期间，不会因为数据或表结构更新，出现备份文件的数据和预期不一样



缺点：

备份期间会造成业务停滞

优化方法：

使用可重复读的隔离级别，即使其他事务更新了表的数据，也不会音响备份数据库时的Read View





# 表级锁

## 表锁

```MySQL 
lock tables student read;	//读锁
 
lock tables student write;  //写锁
```



表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作



```MySQL 
unlock tables 会释放当前会话的所有表锁
```

会话退出后，会自动释放所有表锁



InnoDB 引擎实现了颗粒度更细的行级锁，尽量避免使用表锁



## 元数据锁

MDL

保证用户对表执行CRUD 操作时，**防止其他线程对这个表结构做变更**





当我们对数据库表进行操作时，会自动给这个表加上MDL （**自动上锁**）

- 对表进行CRUD 操作时，自动加MDL 读锁（不能再申请MDL 写锁）
- 对表进行结构变更操作时，自动加MDL 写锁（不能再申请MDL 读锁）

加上锁后，其他操作会被阻塞



MDL 在事务提交后释放

写锁的获取优先级高于读锁，当出MDL 写锁等待，会阻塞后续该表的所有CRUD 操作，就会有大量的线程被阻塞



对表结构变量前，先检查是否有长事务上了读锁，如果可以，先杀掉这个长事务后，再做表结构变更



## 意向锁

在使用InnoDB引擎的表里对某些记录上共享锁之前，需要先在表级别上加一个“意向共享锁”

在使用InnoDB引擎的表里对某些记录上独占锁之前，需要先在表级别上加一个“意向独占锁”



在执行插入、更新、删除 操作前，需要先对表加上意向独占锁，然后再对该记录加独占锁



普通的Select语句是不会加行级锁的（使用MVCC实现一致性读）





意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁发生冲突



表锁和行锁是满足读读共享，读写互斥，写写互斥



好处：快速判断表里是否有记录被加锁

有意向锁之后，由于对记录加独占锁之前，先会加上表级别的意向独占锁，因此，在加“独占表锁”时，直接查该表是否有意向独占锁

如果有了意向独占锁，那么表里就有了记录被加上了独占锁 ---- 不用再去遍历表里的记录



## AUTO-INC锁

自增的实现方式



AUTO-INC 锁是在执行完插入语句后就会立即释放的锁，而不用等到一个事务提交后才去释放



在插入数据的时候，会先加上一个表级别的AUTO-INC锁，然后给自增字段赋一个值，插入语句执行完成后，释放锁



当一个事务持有AUTO-INC锁时，其他事务如果要向该表插入语句会被阻塞，保证了字段的值是连续递增的



在有大量数据进行插入时，AUTO-INC 锁会影响性能



5.1.22版本开始，另一种实现自增的方式（轻量级的锁）：

在给自增字段赋一个值后，就会把锁释放掉，而不用等到整个插入语句都执行完之后再释放（现在是一个字段修改后就释放，原来是要等到所有字段都修改完后再释放）

innodb_autoinc_lock_mode = 0: AUTO-INC 锁

​						= 1： 普通的insert 语句会使用轻量级锁，而insert...select 批量插入时，还是会等到语句结束后才释放

​						= 2：所有的语句都是使用轻量级锁



当搭配binlob  的日志格式是statement 一起使用时，在“主从复制的场景”中就会发生数据不一致



**binlob 日志是什么 ？？？ **

binlog_formate=statement 表示记录的语句是原始语句

binlog 拿去从库执行，只会是顺序执行的结果，与原来相互交叉的场景不一致



当innodb_autoinc_lock_mode=2 且binlog_format = row 时，既能提高并发性，又不会出现数据一致性问题





# 行级锁

InnoDB 引擎支持行级锁， 而MyISAM 引擎不支持行级锁



锁定读：在查询时对记录加行锁

```MySQL 
select ... lock in share mode;  // 对读取的记录加共享锁（S锁）

select ... for update; 	//对读取的记录加独占锁（X锁）
```





## Record Lock

记录锁

锁的是<font color="red">一条记录</font>

记录锁有S 锁（共享锁）和 X锁（独占锁）两种



S 与S 兼容

S 与X 不兼容

X 与X 不兼容



当事务执行commit 后，事务过程中加的锁都会被释放





## Gap Lock

间隙锁

只存在于可重复读隔离级别

目的是为了解决可重复读情况下的幻读

间隙锁之间是兼容的

两个事务可以同时持有包含共同间隙范围锁，而不存在互斥



**锁定一个范围，但不包含记录本身**

id 为(3, 5) 的间隙锁，其他事务无法插入id=4 的记录



## Next-Key Lock

临键锁

<font color="red">与Record Lock组合在一起，锁定一个范围，并且锁定记录本身</font>



id为(3, 5] 的next-key lock，其他事务既不能插入id=4 的记录，也不能修改id=5 的记录



同时包含间隙锁和记录锁， --- 因此可能会因为记录锁而出现阻塞



## 插入意向锁

如果插入的位置上有其他事务加上了间隙锁，那么就会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但现在是等待状态



是一种特殊的间隙锁，属于行级别锁



MySQL 加锁时，**先生成锁结构，再设置锁的状态**

如果锁的状态是等待状态，并不代表事务成功获取到了锁

当锁的状态是正常状态，才代表事务成功得到了锁



插入意向锁 锁住的是一个<font color="red">**点**</font>



插入意向锁 只用于并发插入操作



两个事务不能在同一时间内， 一个拥有间隙锁， 另一个拥有同一个间隙区间内的插入意向锁



生成时机：每插入一条新记录，都需要查询待插入记录的下一条记录上是否有间隙锁，如果已经加了间隙锁，就会生成一个插入意向锁，然后将锁的状态设置为等待状态，----- Insert语句会被阻塞

（有间隙锁，才会有插入意向锁）



两个事务的间隙锁，可以锁定相同的区间　--- 本质上都是不想让其他事务在这个区间上插入新的值（避免出现幻读）



# MySQL 的上锁机制

行级锁的使用情况：

MyISAM引擎不支持行级锁

除了串行化隔离级别，普通的Select语句并不会加锁

update 和delete 语句都会加行级锁，且加的锁的类型上独占锁



**在不同的隔离级别下，行级锁的种类是不一样的**

在读已提交隔离级别时，行级锁的种类只有记录锁，仅把**一条记录**锁上

在可重复读隔离级别时，行级锁的种类有记录锁和间隙锁





## 加锁方式

### 加锁方式的查询语句

```MySQL 
select * from performance_schema.data_locks\G;
```



### 锁的类型表示(LOCK_MODE)

| X              | next-key lock |
| -------------- | ------------- |
| X, REC_NOT_GAP | record        |
| X, GAP         | gap lock      |









不同的场景加锁的方式不同

**加锁的对象是索引**，加锁的基本单位是next-key lock(=record lock + gap lock)

next-key lock 是**前开后闭**区间，而间隙锁是前开后开区间



next-key lock 会退化为记录锁或间隙锁：

​	在能使用记录锁或间隙锁就能避免幻读现象的场景下，会退化



### 唯一索引等值查询

1、查询的记录存在时，在索引树上定位到这一条记录后，就会将该记录的索引中的next-key lock 退化为记录锁



2、查询的记录不存在时，在索引树找到第一条大于该查询记录的记录后，会将该记录的索引中的next-key lock 退化为间隙锁



如果是二级索引的唯一索引，除了会对二级索引项加行级锁，还会对查询到的记录的**主键索引项上加记录锁**



| 存在   | X型记录锁 |
| ------ | --------- |
| 不存在 | 间隙锁    |



幻读：一个事务前后两次查询的结果集不相同

避免幻读： 避免 	1、某一条记录被其他事务删除，或2、是有其他事务插入一条新记录



#### 1、记录存在时

由于主键有唯一性，因此当其他事务插入相同索引时，会发生主键冲突，无法插入新的记录

而对主键加上记录锁，其他事务就无法删除该记录



#### 2、记录不存在时

间隙锁的范围：

第一条大于该查询记录的记录A为右边界

A的上一条记录的索引值为左边界



只要保证前后两次查询的结果是相同的就可以了

因此当记录不存在时，只要把这个结果区间锁上，让其无法再插入新的值，结果集中就仍然会是空的



记录锁是加在索引上的，当查询的记录是不存在时，没办法锁住一条记录，所以不能用记录锁



### 唯一索引范围查询

会对**每一个扫描到的索引加next-key 锁**，等值时可能会有一些变化



1、大于等于 

由于有等值查询，如果等值查询的记录存在于表中，就会将该记录的索引中的next=key 退化为记录锁

2、小于或小于等于

需要判断等号的情况（条件值）是不是存在于表中

​	如果条件值记录不在表中，扫描到终止范围查询的记录时，该记录的索引会退化为间隙锁，其他扫描到的记录，是在这些记录的索引上加临键锁

​	如果条件值记录在表中，如果是 “小于” 查询，扫描到终止范围查询的记录时，该记录的索引的next-key 会退化为间隙锁，其他扫描到的记录，是在这些记录的索引上加临键锁

​			如果是“小于等于”查询，扫描到终止范围查询的记录时，该记录的索引next-key 锁**不会退化为间隙锁**，其他扫描到的记录，在这些记录的索引上加next-key 锁





在InnoDB引擎中，有一个特殊的记录来标识最后一条记录 --- supremum pseudo-record





### 非唯一索引等值查询

有两个索引 ====  主键索引 + 非唯一索引 

在加锁时会对这两个索引都加锁， 但对于主键索引，只有满足查询记录才会对它们的主键索引加锁



#### 1、查询结果存在：

- 非唯一索引等值查询是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录才停止，然后在扫描的过程中，**对扫描到的二级索引记录加的是next-key 锁**，而对于第一个**不符合条件的二级索引记录，会退化成间隙锁**，

- 在符合查询条件的记录的**主键索引上加记录锁**



在不符合条件的二级索引记录上会加上一个间隙锁，是因为：如果只在符合条件的二级索引上加上next-key lock，如果新插入的二级索引值是右边界值，如果id 大于他的id 值，就会向该记录的后面插入一条更大的主键值的，具有相同二级索引的一条新记录

在成功插入后，如果再执行相同的查询语句，就会多一条记录，结果数量不相同 ==== 出现幻读



而如果在后面加一个间隙锁，就可以在插入更大id 值时，发生阻塞，阻止新记录的插入





#### 2、查询如果不存在：

- 扫描到第一条不符合条件的二级索引记录后，该二级索引的next-key锁会退化成间隙锁
- 主键不会加锁



在二级索引树上，是按照二级索引值顺序存放的，在相同的二级索引值情况下，再按主键id 的顺序存放（先二级排，再按主键排）



**插入语句阻塞的情况：**

插入语句在插入一条记录之前，需要先定位该记录在B+树的位置，如果插入的位置的下一条记录的索引上有间隙锁，会发生阻塞



LOCK_DATA（锁住的边界值）会显示两个值，一个是二级索引的右边界值，另一个是对应的主键值

当插入的值为右边界值时，只有当主键值比LOCK_DATA 记录的id值大才能插入





### 非唯一索引范围查询

索引的next-key lock不会退化为间隙锁或记录锁

所有的锁都是next-key lock



只要是满足条件的二级索引记录，就要在它对应的主键索引上加上一个记录锁



### 没有加索引的查询

锁定读查询（select ... for update):

​	会对每一条记录的索引都加上next-key lock，相当于锁住全表的



对于update 和delete 语句，如果查询条件不加索引，也会是全盘扫描，这个时候也会把所有记录都锁上next-key lock



只要是具有加锁性质的语句，如果执行的是全盘扫描，就会对每个索引加上next-key lock，会把整个表的记录都锁住



执行update 语句时，会对记录加独占锁，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的，且锁只有在等到事务结束才会释放，而不是执行完update语句之后就会释放（在InnoDB引擎中可重复读级别下，锁的基本单位是next-key lock)

扫描到每一个记录时，都会加上锁

直到事务结束，只能执行select ... from 语句，其他语句都会被阻塞 



where 带上索引列后，如果优化器最终选择的是全表扫描而不是索引扫描，可以指定索引`force index([idex_name])`



还可以`sql_safe_updates=1`，开启安全更新模式：

update:

- where 且有索引列

- limit
- where 加 limit，where 可以没有索引列

delete:

- 同时使用limit 和 where，此时where 可以没有索引列



# 死锁

对于这种范围为 (1006, +∞] 的 next-key lock，两个事务是可以同时持有的，不会冲突。因为 +∞ 并不是一个真实的记录，自然就不需要考虑 X 型与 S 型关系。





一般情况下，Insert语句会依赖聚簇索引记录自带的trx_id 隐藏列来作为隐式锁，而不会生成锁



## 隐式锁

当事务需要加锁时，如果这个锁不可能发生冲突，InnoDB 会跳过加锁环节

​	一种延迟加锁的机制



在一些情况下，会将隐式锁转换为显式锁

- 记录之间有间隙锁  <font color="red" size=5>??????</font>
    - 显式的是不是生成一个插入意向锁？？
- 遇到唯一键冲突
    - 可以有多条记录的唯一二级索引列的值同时为NULL
    - 会给冲突的记录加上S型锁 -- 读锁
        - 如果主键索引重复，插入新记录的事务除了报错之外，还会对那条记录加上S 型的记录锁
        - 如果是唯一二级索引重复，插入新记录的事务除了报错之外，还会给那条存在的记录加止S 型next-key 锁



例： 事务A，B前后执行相同insert 语句（唯一索引为100)：

​	后执行的语句，会发生阻塞

​	A先插入100这条记录，成功。当前唯一二级索引记录只有隐式锁保护，还没有实际的锁结构

​	当B执行该语句时，由于事务已经插入了一条新记录，所以B会遇到重复的唯一索引值。当B想获取一个S型锁时，由于A并没有提交事务，事务A在100这条记录上的隐式锁会变为显式锁，且锁的类型为X型记录锁，因此B获取S型next-key lock 会发生锁冲突，事务B阻塞

​	直到A 提交事务释放锁后，B才会去加锁



并发多个事务时，

开始是隐式锁，只有当有重复记录被其他事务插入时，才会变成X型的记录锁



## 避免死锁

必要条件：

互斥，占有且等待，不可强占用，循环等待





数据库有两种方法解除：

1、 设置事务等待锁的超时时间

​	当一个事务的等待时间超过设置时间后，就会对这个事务进行回滚

​	默认值为50秒



2、开启主动死锁检测 

​	主动回滚锁链条中的某一个事务，让其他事务可以继续执行

​	默认开启状态





# 字节

A B同时持有一个间隙锁

这时再进行插入操作想加的插入意向锁就会阻塞，阻止数据的插入

两个事务同时等待对方释放自己的间隙锁，就会发生循环等待，发生死锁



























